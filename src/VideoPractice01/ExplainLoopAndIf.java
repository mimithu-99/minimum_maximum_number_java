package VideoPractice01;

public class ExplainLoopAndIf {
}
/*
for (int row = 0; row < 3; row++) {
    for (int column = 0; column < 3; column++) {
        if(abc[row][column] < minimumNumber) {
            minimumNumber = abc[row][column];
            minimumColumn = column;
        }
    }
}
প্রথম লুপের ব্যাখ্যা (বাইরের লুপ):


for (int row = 0; row < 3; row++) {
উদ্দেশ্য: এই লুপটি 2D অ্যারের প্রতিটি সারি (row) এর উপর দিয়ে যায়।
Initialization (int row = 0): এখানে, row ভেরিয়েবলটি 0 দিয়ে শুরু করা হয়েছে, যা প্রথম সারি নির্দেশ করে।
Condition (row < 3): এই শর্তটি চেক করে row এর মান ৩ এর কম কিনা। যদি সত্য হয়, তাহলে লুপটি চলবে। আমাদের অ্যারেটিতে ৩টি সারি আছে, তাই ০ থেকে ২ পর্যন্ত (মোট ৩টি) চলবে।
Increment (row++): প্রতিবার লুপটি চলার পর row এর মান ১ করে বৃদ্ধি পাবে, অর্থাৎ row ০ থেকে ১, তারপর ২ এ যাবে।
দ্বিতীয় লুপের ব্যাখ্যা (ভিতরের লুপ):


for (int column = 0; column < 3; column++) {
উদ্দেশ্য: এই লুপটি প্রতিটি সারির প্রতিটি কলাম (column) এর উপর দিয়ে যায়।
Initialization (int column = 0): এখানে, column ভেরিয়েবলটি 0 দিয়ে শুরু করা হয়েছে, যা প্রথম কলাম নির্দেশ করে।
Condition (column < 3): এই শর্তটি চেক করে column এর মান ৩ এর কম কিনা। যদি সত্য হয়, তাহলে লুপটি চলবে। আমাদের অ্যারেটিতে ৩টি কলাম আছে, তাই ০ থেকে ২ পর্যন্ত (মোট ৩টি) চলবে।
Increment (column++): প্রতিবার লুপটি চলার পর column এর মান ১ করে বৃদ্ধি পাবে, অর্থাৎ column ০ থেকে ১, তারপর ২ এ যাবে।
লুপের অভ্যন্তরে কাজের ব্যাখ্যা:

if(abc[row][column] < minimumNumber) {
    minimumNumber = abc[row][column];
    minimumColumn = column;
}
if শর্ত:


if(abc[row][column] < minimumNumber) {
উদ্দেশ্য: এই শর্তটি চেক করে যে বর্তমান উপাদানটি (abc[row][column]) minimumNumber এর চেয়ে ছোট কিনা।
কেন করা হচ্ছে: কারণ আমরা সর্বনিম্ন সংখ্যা খুঁজে বের করতে চাই।
minimumNumber এবং minimumColumn আপডেট:


minimumNumber = abc[row][column];
minimumColumn = column;
উদ্দেশ্য: যদি বর্তমান উপাদানটি minimumNumber এর চেয়ে ছোট হয়, তাহলে সেটি নতুন minimumNumber হিসেবে গ্রহণ করা হয়।
minimumColumn আপডেট: এছাড়াও, আমরা minimumColumn ভেরিয়েবলটিতে বর্তমান কলামের নম্বর সংরক্ষণ করি যাতে পরে এই কলামটি ব্যবহার করা যায়।
সারাংশ:
বাইরের লুপটি সারি (row) এর জন্য এবং ভিতরের লুপটি কলাম (column) এর জন্য ব্যবহৃত হয়।
প্রতিটি সারি এবং কলামের প্রতিটি উপাদান চেক করা হয় যাতে 2D অ্যারের প্রতিটি উপাদান পরীক্ষা করা যায়।
যদি কোনো উপাদান minimumNumber এর চেয়ে ছোট হয়, তাহলে সেটিকে minimumNumber হিসেবে গ্রহণ করা হয় এবং সেই উপাদানের কলামের নম্বর minimumColumn এ সংরক্ষণ করা হয়।
এই লুপগুলির মাধ্যমে পুরো 2D অ্যারের প্রতিটি উপাদান পরীক্ষা করা হয় এবং সর্বনিম্ন সংখ্যাটি এবং তার অবস্থান (কলাম) খুঁজে বের করা হয়।


 */
/*
int maximumNumber = abc[0][minimumColumn];
int k = 0;
while (k < 3) {
    if (abc[k][minimumColumn] > maximumNumber) {
        maximumNumber = abc[k][minimumColumn];
    }
    k++;
}
লাইনের বিস্তারিত ব্যাখ্যা:
প্রথম লাইন:

java
Copy code
int maximumNumber = abc[0][minimumColumn];
কাজ: maximumNumber নামের একটি ভেরিয়েবল তৈরি করা হয়েছে এবং তাকে abc অ্যারের প্রথম সারির minimumColumn এর উপাদান দিয়ে initialize করা হয়েছে।
কীভাবে: অ্যারের প্রথম সারি (row 0) এবং পূর্বে নির্ধারিত minimumColumn এর মান ব্যবহার করে।
কেন: maximumNumber হিসেবে কোনো প্রাথমিক মান দিতে হবে যাতে আমরা লুপের মধ্যে প্রতিটি উপাদানের সাথে তুলনা করতে পারি।
দ্বিতীয় লাইন:

java
Copy code
int k = 0;
কাজ: k নামের একটি ভেরিয়েবল তৈরি করা হয়েছে এবং তাকে 0 দিয়ে initialize করা হয়েছে।
কীভাবে: সরাসরি int টাইপ ভেরিয়েবল হিসেবে 0 দিয়ে initialize করা হয়েছে।
কেন: লুপের মধ্যে ব্যবহার করার জন্য একটি কাউন্টার ভেরিয়েবল দরকার যা সারি (row) এর অবস্থান নির্দেশ করবে।
তৃতীয় লাইন:

java
Copy code
while (k < 3) {
কাজ: একটি while লুপ শুরু হয়েছে যা ৩ বার চলবে।
কীভাবে: k এর মান 3 এর কম থাকলে লুপটি চলবে।
কেন: আমাদের ২D অ্যারেটির ৩টি সারি আছে, তাই লুপটি ৩ বার চলবে (০ থেকে ২ পর্যন্ত)।
চতুর্থ লাইন:

java
Copy code
if (abc[k][minimumColumn] > maximumNumber) {
কাজ: চেক করে বর্তমান উপাদানটি maximumNumber এর চেয়ে বড় কিনা।
কীভাবে: abc[k][minimumColumn] এর মান এবং maximumNumber এর মান তুলনা করা হচ্ছে।
কেন: আমরা সর্বোচ্চ সংখ্যা খুঁজে বের করতে চাই, তাই যদি বর্তমান উপাদানটি maximumNumber এর চেয়ে বড় হয়, তাহলে সেটিকে maximumNumber হিসেবে ধরে নেয়া হবে।
পঞ্চম লাইন:

java
Copy code
maximumNumber = abc[k][minimumColumn];
কাজ: যদি শর্তটি সত্য হয়, তাহলে বর্তমান উপাদানটি maximumNumber হিসেবে গ্রহণ করা হয়।
কীভাবে: বর্তমান উপাদান (abc[k][minimumColumn]) কে maximumNumber এ অ্যাসাইন করা হচ্ছে।
কেন: আমরা নতুন সর্বোচ্চ সংখ্যাটি খুঁজে পেয়েছি, তাই সেটি maximumNumber হিসেবে গ্রহণ করা হচ্ছে।
ষষ্ঠ লাইন:

java
Copy code
k++;
কাজ: k এর মান ১ করে বৃদ্ধি করা হচ্ছে।
কীভাবে: k এর মান ১ করে বৃদ্ধি করা হয়।
কেন: পরের সারির উপাদান চেক করার জন্য k এর মান বৃদ্ধি করতে হবে।
সারাংশ:
প্রথমে, আমরা সর্বনিম্ন সংখ্যার কলামের প্রথম উপাদানটিকে maximumNumber হিসেবে গ্রহণ করি।
তারপর, একটি while লুপ ব্যবহার করে ঐ কলামের প্রতিটি সারির উপাদান পরীক্ষা করা হয়।
যদি কোনো উপাদান maximumNumber এর চেয়ে বড় হয়, তাহলে সেটিকে নতুন maximumNumber হিসেবে গ্রহণ করা হয়।
এই প্রক্রিয়াটি চলতে থাকে যতক্ষণ না সমস্ত সারির উপাদান চেক করা হয়।
শেষে, আমাদের কাছে সর্বনিম্ন সংখ্যার কলামের সর্বাধিক সংখ্যা থাকবে।
এভাবে, কোডটি পুরো 2D অ্যারের মধ্য থেকে নির্ধারিত কলামের সর্বোচ্চ সংখ্যা খুঁজে বের করে।


 */